ssertion = config.assertions[i];

					var li = document.createElement("li");
					li.className = assertion.result ? "pass" : "fail";
					li.appendChild(document.createTextNode(assertion.message || "(no message)"));
					ol.appendChild( li );

					if ( assertion.result ) {
						good++;
					} else {
						bad++;
						config.stats.bad++;
						config.moduleStats.bad++;
					}
				}

				var b = document.createElement("strong");
				b.innerHTML = name + " <b style='color:black;'>(<b class='fail'>" + bad + "</b>, <b class='pass'>" + good + "</b>, " + config.assertions.length + ")</b>";
				
				addEvent(b, "click", function() {
					var next = b.nextSibling, display = next.style.display;
					next.style.display = display === "none" ? "block" : "none";
				});
				
				addEvent(b, "dblclick", function(e) {
					var target = e && e.target ? e.target : window.event.srcElement;
					if ( target.nodeName.toLowerCase() === "strong" ) {
						var text = "", node = target.firstChild;

						while ( node.nodeType === 3 ) {
							text += node.nodeValue;
							node = node.nextSibling;
						}

						text = text.replace(/(^\s*|\s*$)/g, "");

						if ( window.location ) {
							window.location.href = window.location.href.match(/^(.+?)(\?.*)?$/)[1] + "?" + encodeURIComponent(text);
						}
					}
				});

				var li = document.createElement("li");
				li.className = bad ? "fail" : "pass";
				li.appendChild( b );
				li.appendChild( ol );
				tests.appendChild( li );

				if ( bad ) {
					var toolbar = id("qunit-testrunner-toolbar");
					if ( toolbar ) {
						toolbar.style.display = "block";
						id("qunit-filter-pass").disabled = null;
						id("qunit-filter-missing").disabled = null;
					}
				}

			} else {
				for ( var i = 0; i < config.assertions.length; i++ ) {
					if ( !config.assertions[i].result ) {
						bad++;
						config.stats.bad++;
						config.moduleStats.bad++;
					}
				}
			}

			QUnit.testDone( testName, bad, config.assertions.length );

			if ( !window.setTimeout && !config.queue.length ) {
				done();
			}
		});

		if ( window.setTimeout && !config.doneTimer ) {
			config.doneTimer = window.setTimeout(function(){
				if ( !config.queue.length ) {
					done();
				} else {
					synchronize( done );
				}
			}, 13);
		}
	},
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) {
		config.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) {
		QUnit.log(a, msg);

		config.assertions.push({
			result: !!a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		push(expected != actual, actual, expected, message);
	},
	
	deepEqual: function(a, b, message) {
		push(QUnit.equiv(a, b), a, b, message);
	},

	notDeepEqual: function(a, b, message) {
		push(!QUnit.equiv(a, b), a, b, message);
	},

	strictEqual: function(actual, expected, message) {
		push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		push(expected !== actual, actual, expected, message);
	},
	
	start: function() {
		// A slight delay, to avoid any current callbacks
		if ( window.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13# mime-db

[![NPM Version][npm-version-image]][npm-url]
[![NPM Downloads][npm-downloads-image]][npm-url]
[![Node.js Version][node-image]][node-url]
[![Build Status][travis-image]][travis-url]
[![Coverage Status][coveralls-image]][coveralls-url]

This is a database of all mime types.
It consists of a single, public JSON file and does not include any logic,
allowing it to remain as un-opinionated as possible with an API.
It aggregates data from the following sources:

- http://www.iana.org/assignments/media-types/media-types.xhtml
- http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
- http://hg.nginx.org/nginx/raw-file/default/conf/mime.types

## Installation

```bash
npm install mime-db
```

### Database Download

If you're crazy enough to use this in the browser, you can just grab the
JSON file using [jsDelivr](https://www.jsdelivr.com/). It is recommended to
replace `master` with [a release tag](https://github.com/jshttp/mime-db/tags)
as the JSON format may change in the future.

```
https://cdn.jsdelivr.net/gh/jshttp/mime-db@master/db.json
```

## Usage

```js
var db = require('mime-db');

// grab data on .js files
var data = db['application/javascript'];
```

## Data Structure

The JSON file is a map lookup for lowercased mime types.
Each mime type has the following properties:

- `.source` - where the mime type is defined.
    If not set, it's probably a custom media type.
    - `apache` - [Apache common media types](http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types)
    - `iana` - [IANA-defined media types](http://www.iana.org/assignments/media-types/media-types.xhtml)
    - `nginx` - [nginx media types](http://hg.nginx.org/nginx/raw-file/default/conf/mime.types)
- `.extensions[]` - known extensions associated with this mime type.
- `.compressible` - whether a file of this type can be gzipped.
- `.charset` - the default charset associated with this type, if any.

If unknown, every property could be `undefined`.

## Contributing

To edit the database, only make PRs against `src/custom.json` or
`src/custom-suffix.json`.

The `src/custom.json` file is a JSON object with the MIME type as the keys
and the values being an object with the following keys:

- `compressible` - leave out if you don't know, otherwise `true`/`false` to
  indicate whether the data represented by the type is typically compressible.
- `extensions` - include an array of file extensions that are associated with
  the type.
- `notes` - human-readable notes about the type, typically what the type is.
- `sources` - include an array of URLs of where the MIME type and the associated
  extensions are sourced from. This needs to be a [primary source](https://en.wikipedia.org/wiki/Primary_source);
  links to type aggregating sites and Wikipedia are _not acceptable_.

To update the build, run `npm run build`.

### Adding Custom Media Types

The best way to get new media types included in this library is to register
them with the IANA. The community registration procedure is outlined in
[RFC 6838 section 5](http://tools.ietf.org/html/rfc6838#section-5). Types
registered with the IANA are automatically pulled into this library.

If that is not possible / feasible, they can be added directly here as a
"custom" type. To do this, it is required to have a primary source that
definitively lists the media type. If an extension is going to be listed as
associateed with this media type, the source must definitively link the
media type and extension as well.

[coveralls-image]: https://badgen.net/coveralls/c/github/jshttp/mime-db/master
[coveralls-url]: https://coveralls.io/r/jshttp/mime-db?branch=master
[node-image]: https://badgen.net/npm/node/mime-db
[node-url]: https://nodejs.org/en/download
[npm-downloads-image]: https://badgen.net/npm/dm/mime-db
[npm-url]: https://npmjs.org/package/mime-db
[npm-version-image]: https://badgen.net/npm/v/mime-db
[travis-image]: https://badgen.net/travis/jshttp/mime-db/master
[travis-url]: https://travis-ci.org/jshttp/mime-db
                                                                     {{# def.definitions }}
{{# def.errors }}
{{# def.setupKeyword }}

{{## def._validateRef:_v:
  {{? it.opts.passContext }}
    {{=_v}}.call(this,
  {{??}}
    {{=_v}}(
  {{?}}
    {{=$data}}, {{# def.dataPath }}{{# def.passParentData }}, rootData)
#}}

{{ var $async, $refCode; }}
{{? $schema == '#' || $schema == '#/' }}
  {{
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  }}
{{??}}
  {{ var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot); }}
  {{? $refVal === undefined }}
    {{ var $message = it.MissingRefError.message(it.baseId, $schema); }}
    {{? it.opts.missingRefs == 'fail' }}
      {{ it.logger.error($message); }}
      {{# def.error:'$ref' }}
      {{? $breakOnError }} if (false) { {{?}}
    {{?? it.opts.missingRefs == 'ignore' }}
      {{ it.logger.warn($message); }}
      {{? $breakOnError }} if (true) { {{?}}
    {{??}}
      {{ throw new it.MissingRefError(it.baseId, $schema, $message); }}
    {{?}}
  {{?? $refVal.inline }}
    {{# def.setupNextLevel }}
    {{
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
    }}
    {{ var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code); }}
    {{= $code }}
    {{? $breakOnError}}
      if ({{=$nextValid}}) {
    {{?}}
  {{??}}
    {{
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }}
  {{?}}
{{?}}

{{? $refCode }}
  {{# def.beginDefOut}}
    {{# def._validateRef:$refCode }}
  {{# def.storeDefOut:__callValidate }}

  {{? $async }}
    {{ if (!it.async) throw new Error('async schema referenced by sync schema'); }}
    {{? $breakOnError }} var {{=$valid}}; {{?}}
    try {
      await {{=__callValidate}};
      {{? $breakOnError }} {{=$valid}} = true; {{?}}
    } catch (e) {
      if (!(e instanceof ValidationError)) throw e;
      if (vErrors === null) vErrors = e.errors;
      else vErrors = vErrors.concat(e.errors);
      errors = vErrors.length;
      {{? $breakOnError }} {{=$valid}} = false; {{?}}
    }
    {{? $breakOnError }} if ({{=$valid}}) { {{?}}
  {{??}}
    if (!{{=__callValidate}}) {
      if (vErrors === null) vErrors = {{=$refCode}}.errors;
      else vErrors = vErrors.concat({{=$refCode}}.errors);
      errors = vErrors.length;
    } {{? $breakOnError }} else { {{?}}
  {{?}}
{{?}}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             events.emit('verbose', 'Copying android template project to ' + project_path);

            var project_template_dir = options.customTemplate || path.join(ROOT, 'bin', 'templates', 'project');
            var app_path = path.join(project_path, 'app', 'src', 'main');

            // copy project template
            fs.ensureDirSync(app_path);
            fs.copySync(path.join(project_template_dir, 'assets'), path.join(app_path, 'assets'));
            fs.copySync(path.join(project_template_dir, 'res'), path.join(app_path, 'res'));
            fs.copySync(path.join(project_template_dir, 'gitignore'), path.join(project_path, '.gitignore'));

            // Manually create directories that would be empty within the template (since git doesn't track directories).
            fs.ensureDirSync(path.join(app_path, 'libs'));

            // copy cordova.js, cordova.jar
            exports.copyJsAndLibrary(project_path, options.link, safe_activity_name);

            // Set up ther Android Studio paths
            var java_path = path.join(app_path, 'java');
            var assets_path = path.join(app_path, 'assets');
            var resource_path = path.join(app_path, 'res');
            fs.ensureDirSync(java_path);
            fs.ensureDirSync(assets_path);
            fs.ensureDirSync(resource_path);

            // interpolate the activity name and package
            var packagePath = package_name.replace(/\./g, path.sep);
            var activity_dir = path.join(java_path, packagePath);
            var activity_path = path.join(activity_dir, safe_activity_name + '.java');

            fs.ensureDirSync(activity_dir);
            fs.copySync(path.join(project_template_dir, 'Activity.java'), activity_path);
            utils.replaceFileContents(activity_path, /__ACTIVITY__/, safe_activity_name);
            utils.replaceFileContents(path.join(app_path, 'res', 'values', 'strings.xml'), /__NAME__/, project_name);
            utils.replaceFileContents(activity_path, /__ID__/, package_name);

            var manifest = new AndroidManifest(path.join(project_template_dir, 'AndroidManifest.xml'));
            manifest.setPackageId(package_name)
                .getActivity().setName(safe_activity_name);

            var manifest_path = path.join(app_path, 'AndroidManifest.xml');
            manifest.write(manifest_path);

            exports.copyScripts(project_path);
            exports.copyBuildRules(project_path);

            // Link it to local android install.
            exports.writeProjectProperties(project_path, target_api);
            exports.prepBuildFiles(project_path);
            exports.writeNameForAndroidStudio(project_path, project_name);
            events.emit('log', generateDoneMessage('create', options.link));
        }).then(() => project_path);
};

function generateDoneMessage (type, link) {
    var pkg = require('../../package');
    var msg = 'Android project ' + (type === 'update' ? 'updated ' : 'created ') + 'with ' + pkg.name + '@' + pkg.version;
    if (link) {
        msg += ' and has a linked CordovaLib';
    }
    return msg;
}

// Returns a promise.
exports.update = function (projectPath, options, events) {
    var errorString =
        'An in-place platform update is not supported. \n' +
        'The `platforms` folder is always treated as a build artifact in the CLI workflow.\n' +
        'To update your platform, you have to remove, then add your android platform again.\n' +
        'Make sure you save your plugins beforehand using `cordova plugin save`, and save \n' + 'a copy of the platform first if you had manual changes in it.\n' +
        '\tcordova plugin save\n' +
        '\tcordova platform rm android\n' +
        '\tcordova platform add android\n'
        ;

    return Promise.reject(errorString);
};
